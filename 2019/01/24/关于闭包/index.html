<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="黄侦探"><title>关于闭包 · 侦探事务所</title><meta name="description" content="认识闭包当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行的。123456789function foo()&amp;#123;    var a = 2;    function bar()&amp;#123;        console.log( a );    &amp;#12"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/baidutongji.js"></script></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">侦探事务所</a></h3><div class="description"><p>学海无涯 寻真相</p></div></div></div><ul class="social-links"><li><a href="http://github.com/dc-maggic"><i class="fa fa-github"></i></a></li></ul><div class="footer"><div class="by_farbox"><span>Nice to meet you!</span></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li><li><a href="/links">友链</a></li><li><a href="/albums">相册</a></li><li><a href="/books">书籍</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="/images/littlegirl.jpg"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>关于闭包</a></h3></div><div class="post-content"><h3 id="认识闭包"><a href="#认识闭包" class="headerlink" title="认识闭包"></a>认识闭包</h3><p>当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function foo()&#123;</span><br><span class="line">    var a = 2;</span><br><span class="line">    function bar()&#123;</span><br><span class="line">        console.log( a );</span><br><span class="line">    &#125;</span><br><span class="line">    return bar;</span><br><span class="line">&#125;</span><br><span class="line">var baz = foo();//此时 baz = bar;</span><br><span class="line">baz();//2</span><br></pre></td></tr></table></figure></p>
<p>在 foo() 执行后，其返回值（就是 bar 函数）赋给了变量 baz。<br>然后在调用 baz()，实际调用的是 bar()。<br>bar() 的词法作用域是在 foo() 的内部作用域，而调用执行的位置是在 foo() 的外部作用域。<br>在 foo()执行后，其作用域原本是应该被回收的，但是依然存在没有被回收，是因为 bar() 还在使用。<br>bar()依旧对这个作用域可以引用，这个引用就叫做闭包。</p>
<h3 id="这个不是闭包"><a href="#这个不是闭包" class="headerlink" title="这个不是闭包"></a>这个不是闭包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = 2;</span><br><span class="line">(function IIFE()&#123;</span><br><span class="line">    console.log( a );</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>这个不是闭包，根据闭包的概念，它不是在本身的词法作用域外执行的，它是在定义时所在的作用域种执行。a 是通过普通的此法作用域查找的，而不是闭包发现的。</p>
<h3 id="使用了回调函数就是使用闭包"><a href="#使用了回调函数就是使用闭包" class="headerlink" title="使用了回调函数就是使用闭包"></a>使用了回调函数就是使用闭包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function wait(message)&#123;</span><br><span class="line">    setTimeout( function timer()&#123;</span><br><span class="line">        console.log(message);</span><br><span class="line">    &#125;,1000);</span><br><span class="line">&#125;</span><br><span class="line">wait( &quot;Hello,closure&quot;);</span><br></pre></td></tr></table></figure>
<p>注意：setTimeout()方法一定要传入一个函数的。<br>结果就是在 wait() 执行1000毫秒疑惑，它的内部作用域不会消失， timer 函数依然保有 wait()作用域的闭包。<br>在引擎内部，内置的工具函数 setTimeout() 持有对一个参数的引用，引擎会调用这个函数，在例子中就是内部的 timer 函数，并且词法作用域在这个过程保持完整，这就是闭包。<br>在定时器、事件监听器、Ajax 请求等异步（或者同步）任务中，只要使用了回调函数，实际上就是使用闭包。</p>
<h3 id="在循环里的闭包"><a href="#在循环里的闭包" class="headerlink" title="在循环里的闭包"></a>在循环里的闭包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(var i=1; i&lt;=5; i++)&#123;</span><br><span class="line">    setTimeout( function timer()&#123;</span><br><span class="line">        console.log(i);&#125;,i*1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>预想是分别输出数字1-5，每秒一次，每次一个。<br>结果是以每秒一次的频率输出五次6。<br>因为延迟函数（就是 setTimeout）会在循环结束后才开始执行，循环结束的条件是 i=6，并且 i 的作用域是全局的。<br>循环结束后，延迟函数会执行五次，并且执行的是五次闭包（即 timer())，虽然这五次函数是在各个迭代种分别定义的，但是它们都被封闭在一个共享的全局作用域种，因此实际上只有一个 i，并且 i=6。<br>如果想得到预想结果，我们需要改进一下代码。</p>
<ol>
<li><p>有自己的变量，用在每个迭代中存储 i 的值；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">for(var i=1; i&lt;=5; i++)&#123;</span><br><span class="line">    (function()&#123;  //这里创造了一个内部的作用域，当执行五次闭包时，它的作用域在这里，并且变量 j 也被储存下来了。</span><br><span class="line">        var j = i;</span><br><span class="line">        setTimeout( function timer()&#123;</span><br><span class="line">        console.log(j);&#125;,j*1000);</span><br><span class="line">    &#125;)();</span><br><span class="line">&#125;</span><br><span class="line">//进一步改善</span><br><span class="line">for(var i=1; i&lt;=5; i++)&#123;</span><br><span class="line">    (function(j)&#123;</span><br><span class="line">        setTimeout( function timer()&#123;</span><br><span class="line">            console.log(j);&#125;,j*1000);</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>引入块作用域<br>使用 let 关键字（可以将变量绑定到所在的任意作用域种（通常是{…}内部）），引入块作用域。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">for( var i=1; i&lt;=5; i++)&#123;//这里创建块作用域。</span><br><span class="line">    let j = i;           //注意是 let 而不是 var，否则还是全局作用域。</span><br><span class="line">    setTimeout( function timer()&#123;</span><br><span class="line">        console.log(j);&#125;,j*1000);</span><br><span class="line">&#125;</span><br><span class="line">//或者</span><br><span class="line">for( let i=1; i&lt;=5; i++)//圆括号这里创建块作用域。</span><br><span class="line">    &#123;</span><br><span class="line">    setTimeout( function timer()&#123;</span><br><span class="line">        console.log(j);&#125;,j*1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>总之，加入块作用域或者新的作用域（函数作用域等），使用闭包就十分方便。</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2019-01-24</span><i class="fa fa-tag"></i><a class="tag" href="/tags/JavaScript/" title="JavaScript">JavaScript </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,http://dc-maggic.github.io/2019/01/24/关于闭包/,侦探事务所,关于闭包,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2019/01/25/闭包的几个经典题目/" title="闭包的几个经典题目">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2019/01/23/关于原型的属性设置和屏蔽/" title="关于原型的属性设置和屏蔽">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>